// Script de test pour v√©rifier le masquage des briques fant√¥mes
// Ex√©cutez dans la console du navigateur : testGhostElementMasking()

function testGhostElementMasking() {
    console.log('üîç Test du masquage des √©l√©ments fant√¥mes pour export PDF');
    console.log('=======================================================');
    
    // Test 1: V√©rifier les √©l√©ments fant√¥mes connus
    console.group('üìã 1. Diagnostic des √©l√©ments fant√¥mes connus');
    
    const ghostElements = [];
    
    // ConstructionTools
    if (window.ConstructionTools) {
        if (window.ConstructionTools.ghostElement && window.ConstructionTools.ghostElement.mesh) {
            ghostElements.push({
                source: 'ConstructionTools.ghostElement.mesh',
                element: window.ConstructionTools.ghostElement.mesh,
                visible: window.ConstructionTools.ghostElement.mesh.visible,
                position: window.ConstructionTools.ghostElement.mesh.position,
                opacity: window.ConstructionTools.ghostElement.mesh.material ? window.ConstructionTools.ghostElement.mesh.material.opacity : 'N/A'
            });
        }
        
        if (window.ConstructionTools.ghostBrick) {
            ghostElements.push({
                source: 'ConstructionTools.ghostBrick',
                element: window.ConstructionTools.ghostBrick,
                visible: window.ConstructionTools.ghostBrick.visible,
                position: window.ConstructionTools.ghostBrick.position
            });
        }
        
        if (window.ConstructionTools.previewElement && window.ConstructionTools.previewElement.mesh) {
            ghostElements.push({
                source: 'ConstructionTools.previewElement.mesh',
                element: window.ConstructionTools.previewElement.mesh,
                visible: window.ConstructionTools.previewElement.mesh.visible,
                position: window.ConstructionTools.previewElement.mesh.position
            });
        }
        
        if (window.ConstructionTools.currentGhost) {
            ghostElements.push({
                source: 'ConstructionTools.currentGhost',
                element: window.ConstructionTools.currentGhost,
                visible: window.ConstructionTools.currentGhost.visible,
                position: window.ConstructionTools.currentGhost.position
            });
        }
    }
    
    // PlacementManager
    if (window.PlacementManager) {
        if (window.PlacementManager.ghostElement) {
            ghostElements.push({
                source: 'PlacementManager.ghostElement',
                element: window.PlacementManager.ghostElement,
                visible: window.PlacementManager.ghostElement.visible,
                position: window.PlacementManager.ghostElement.position
            });
        }
        
        if (window.PlacementManager.previewMesh) {
            ghostElements.push({
                source: 'PlacementManager.previewMesh',
                element: window.PlacementManager.previewMesh,
                visible: window.PlacementManager.previewMesh.visible,
                position: window.PlacementManager.previewMesh.position
            });
        }
    }
    
    if (ghostElements.length === 0) {
        console.log('‚úÖ Aucun √©l√©ment fant√¥me d√©tect√© dans les managers connus');
    } else {
        ghostElements.forEach((ghost, index) => {
            console.log(`${ghost.visible ? 'üëª' : 'üö´'} ${ghost.source}:`, {
                visible: ghost.visible,
                position: ghost.position ? `(${ghost.position.x.toFixed(1)}, ${ghost.position.y.toFixed(1)}, ${ghost.position.z.toFixed(1)})` : 'N/A',
                opacity: ghost.opacity
            });
        });
    }
    console.groupEnd();
    
    // Test 2: Balayage de la sc√®ne pour √©l√©ments suspects
    console.group('üîç 2. Balayage de la sc√®ne pour √©l√©ments fant√¥mes');
    
    if (!window.SceneManager || !window.SceneManager.scene) {
        console.error('‚ùå SceneManager.scene non disponible');
        console.groupEnd();
        return;
    }
    
    let suspiciousElements = [];
    let totalMeshes = 0;
    
    window.SceneManager.scene.traverse((object) => {
        if (object.isMesh) {
            totalMeshes++;
            
            let suspicious = false;
            let reasons = [];
            
            // Opacit√© suspecte
            if (object.material && object.material.opacity !== undefined && object.material.opacity < 1.0) {
                suspicious = true;
                reasons.push(`opacity=${object.material.opacity}`);
            }
            
            // UserData suspect
            if (object.userData && (
                object.userData.ghost || object.userData.isGhost ||
                object.userData.preview || object.userData.isPreview ||
                object.userData.phantom || object.userData.temporary ||
                object.userData.cursor || object.userData.suggestion ||
                object.userData.floating || object.userData.dragging
            )) {
                suspicious = true;
                const suspectKeys = Object.keys(object.userData).filter(key => 
                    key.includes('ghost') || key.includes('preview') || key.includes('phantom') ||
                    key.includes('temp') || key.includes('cursor') || key.includes('suggestion')
                );
                reasons.push(`userData: ${suspectKeys.join(', ')}`);
            }
            
            // Nom suspect
            if (object.name && (
                object.name.toLowerCase().includes('ghost') ||
                object.name.toLowerCase().includes('preview') ||
                object.name.toLowerCase().includes('phantom') ||
                object.name.toLowerCase().includes('temp') ||
                object.name.toLowerCase().includes('cursor') ||
                object.name.toLowerCase().includes('fantome')
            )) {
                suspicious = true;
                reasons.push(`name="${object.name}"`);
            }
            
            // Position extr√™me
            if (object.position && (
                object.position.y > 1000 || object.position.y < -1000 ||
                Math.abs(object.position.x) > 5000 || Math.abs(object.position.z) > 5000
            )) {
                suspicious = true;
                reasons.push(`position=(${object.position.x.toFixed(1)}, ${object.position.y.toFixed(1)}, ${object.position.z.toFixed(1)})`);
            }
            
            if (suspicious) {
                suspiciousElements.push({
                    object: object,
                    name: object.name || 'unnamed',
                    visible: object.visible,
                    reasons: reasons,
                    position: object.position ? `(${object.position.x.toFixed(1)}, ${object.position.y.toFixed(1)}, ${object.position.z.toFixed(1)})` : 'N/A'
                });
            }
        }
    });
    
    console.log(`üìä Total: ${totalMeshes} meshes dans la sc√®ne, ${suspiciousElements.length} √©l√©ments suspects d√©tect√©s`);
    
    if (suspiciousElements.length > 0) {
        suspiciousElements.forEach((suspect, index) => {
            console.log(`${suspect.visible ? 'üëª' : 'üö´'} ${suspect.name}:`, {
                visible: suspect.visible,
                position: suspect.position,
                reasons: suspect.reasons.join(' | ')
            });
        });
    } else {
        console.log('‚úÖ Aucun √©l√©ment suspect d√©tect√© dans la sc√®ne');
    }
    console.groupEnd();
    
    // Test 3: Simulation du masquage
    console.group('üß™ 3. Test de simulation du masquage');
    
    console.log('üîÑ Application des r√®gles de masquage...');
    
    let maskedCount = 0;
    const maskedElements = [];
    
    // Masquer les √©l√©ments connus
    ghostElements.forEach(ghost => {
        if (ghost.element && ghost.element.visible) {
            ghost.element.visible = false;
            maskedCount++;
            maskedElements.push(ghost);
            console.log(`üö´ Masqu√©: ${ghost.source}`);
        }
    });
    
    // Masquer les √©l√©ments suspects visibles
    suspiciousElements.forEach(suspect => {
        if (suspect.object.visible) {
            suspect.object.visible = false;
            maskedCount++;
            maskedElements.push(suspect);
            console.log(`üö´ Masqu√©: ${suspect.name} (${suspect.reasons.join(', ')})`);
        }
    });
    
    console.log(`‚úÖ Total masqu√©: ${maskedCount} √©l√©ments`);
    
    // Restaurer apr√®s 3 secondes pour voir la diff√©rence
    setTimeout(() => {
        console.log('üîÑ Restauration des √©l√©ments masqu√©s...');
        maskedElements.forEach(element => {
            if (element.element) {
                element.element.visible = true;
            } else if (element.object) {
                element.object.visible = true;
            }
        });
        console.log('‚úÖ √âl√©ments restaur√©s');
    }, 3000);
    
    console.groupEnd();
    
    // Test 4: Recommandations
    console.group('üí° 4. Recommandations');
    
    if (ghostElements.length > 0 || suspiciousElements.length > 0) {
        console.log('‚ö†Ô∏è √âl√©ments fant√¥mes d√©tect√©s. V√©rifications recommand√©es:');
        console.log('1. üîç Observez la sc√®ne 3D pendant les 3 prochaines secondes');
        console.log('2. üìÑ Testez un export PDF pour voir si les fant√¥mes sont masqu√©s');
        console.log('3. üõ†Ô∏è Si des fant√¥mes persistent, ajoutez des crit√®res de masquage sp√©cifiques');
        
        if (ghostElements.some(g => g.visible)) {
            console.log('‚ö†Ô∏è ATTENTION: Des √©l√©ments fant√¥mes sont encore VISIBLES');
        }
    } else {
        console.log('‚úÖ Aucun √©l√©ment fant√¥me d√©tect√© - L\'export PDF devrait √™tre propre');
    }
    
    console.groupEnd();
    
    return {
        ghostElementsFound: ghostElements.length,
        suspiciousElementsFound: suspiciousElements.length,
        totalMasked: maskedCount,
        recommendation: maskedCount > 0 ? 'Test PDF pour v√©rification' : 'Export PDF devrait √™tre propre'
    };
}

// Fonction pour tester sp√©cifiquement pendant un export PDF
function testDuringPDFExport() {
    console.log('üîÑ Test pendant export PDF...');
    
    if (!window.presentationManager) {
        console.error('‚ùå presentationManager non disponible');
        return;
    }
    
    // Intercepter la fonction de masquage
    const originalDisableVisualAids = window.presentationManager.disableVisualAidsForExport;
    
    window.presentationManager.disableVisualAidsForExport = function() {
        console.log('üìã D√©but du masquage pour export PDF');
        
        // Appeler la fonction originale
        const result = originalDisableVisualAids.call(this);
        
        // Test apr√®s masquage
        setTimeout(() => {
            testGhostElementMasking();
        }, 100);
        
        return result;
    };
    
    console.log('‚úÖ Test configur√© - Lancez maintenant un export PDF');
    
    // Restaurer apr√®s un certain temps
    setTimeout(() => {
        window.presentationManager.disableVisualAidsForExport = originalDisableVisualAids;
        console.log('üîÑ Fonction de masquage restaur√©e');
    }, 30000); // 30 secondes
}

// Exposer les fonctions
window.testGhostElementMasking = testGhostElementMasking;
window.testDuringPDFExport = testDuringPDFExport;

console.log('üéØ Script de test des √©l√©ments fant√¥mes charg√© !');
console.log('üìö Fonctions disponibles:');
console.log('- testGhostElementMasking(): Test g√©n√©ral des √©l√©ments fant√¥mes');
console.log('- testDuringPDFExport(): Test pendant un export PDF');